[{"title":"Hello World","date":"2021-09-03T08:58:08.921Z","url":"/2021/09/03/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"什麼是對使用者友好","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E4%BB%80%E9%BA%BC%E6%98%AF%E5%B0%8D%E4%BD%BF%E7%94%A8%E8%80%85%E5%8F%8B%E5%A5%BD/","tags":[["当然我在扯淡","/tags/%E5%BD%93%E7%84%B6%E6%88%91%E5%9C%A8%E6%89%AF%E6%B7%A1/"],["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"]],"categories":[["PHP","/categories/PHP/"]],"content":"Type theory 這個系統有多個模組，包括機器模組和人類模組 機器模組之間的界面使用定義好的 API 接口。 人機互動的界面就是機器模組和人類模組之間的接口。 每個界面必須提供一定的抽象，用於防止使用者得到它不該知道的細節。這個使用者可能是機器模組，也可能是人類模組。 抽象使得系統具有可擴展性。因為只要界面不變，模組改動之後，它的使用者完全不用修改。 使用者也是系統的模組在機器的各個模組間，抽象表現為函數或者方法的類型（type），程式的模組（module）定義，操作系統的系統調用（system call），等等。但是它們的本質都是一樣的：他們告訴使用者「你能用我來幹什麼。」。很多程式開發者都會注意到這些機器界面的抽象，讓使用者盡量少的接觸到實現細節。可是他們卻往往忽視了使用者和機器之間的界面。 也許他們沒有忽視它，但是他們卻用非常不一樣的設計思想來考慮這個問題。「他們沒有真正把使用者當成這個系統的一部分，沒有像對待其它機器模塊一樣，提供具有良好抽象的界面給使用者。他們貌似覺得使用者應該可以多做一些事情，所以把紛繁複雜的程序內部結構暴露給使用者（包括他們自己）。」 所以，使用者對”我能用這個程式幹什麼”這個問題總是感到很糊塗。當程式被修改之後，還經常需要讓使用者的操作發生改變，所以這個系統對於使用者的可擴展性就差。通常程式開發者都考慮到機器各界面之間的擴展性，卻沒有考慮到機器與使用者之間界面的可擴展性。 如何對使用者更加友好 統一 隨時注意，使用者是系統的一部分，而不是什麼古怪的神物基本上可以把使用者想像成一個程式模組。 抽象 最大限度的掩蓋程式內部的實現，盡量不讓使用者知道他不必要知道的東西不願意暴露給其它程式模組的細節，也不要暴露給使用者。“機所不欲，勿施於人” 。 充要 提供給使用者充分而必要（不多於）的機制來完成使用者想完成的任務。 正交 機制之間應該盡量減少冗餘和重疊，保持正交（orthogonal）。 组合 機制之間應該可以組合（compose），盡量使得幹同一件事情只有一種組合。 理性 並不是所有使用者想要的功能都是應該有的，他們經常欺騙自己，要搞清楚哪些是他們真正需要的功能。 信道 人的輸入輸出包括5種感官，雖然通常電腦只與人通過視覺和聽覺交互。 直覺 人是靠直覺和模型（model）思考的，給使用者的資訊不管是符號還是圖形，應該容易在人腦中建立起直觀的模型，這樣使用者才能高效的操作它們。 上下文 人腦的「快存」的容量是很小的。試試你能同時想起7個人的名字嗎？所以在任一特定時刻，應該只提供與當前被關注對象相關的操作，而不是提供所有情況下的所有操作供使用者選擇。上下文菜單和依據上下文的鍵盤操作提示，貌似不錯的主意。 Reference什么是“对用户友好”"},{"title":"作業系統 - Introducation","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%20-%20Introducation/","tags":[["Operating System","/tags/Operating-System/"]],"categories":[["undefined",""]],"content":"作業系統：是介於使用者與硬體之間，用來控制硬體的軟體。 作業系統的組成作業系統是一個持續運作在電腦上的軟體程式。 其中 kernel 是 OS 的重要核心之一，它充當著 Process 和 hardware 之間的溝通橋樑。當電腦開機時，最先載入的就是 kernel。 除了 Kernel 以外還有另外兩種程式分別是： System Programe：與 OS 相關，但不一定與 Kernel 相關 Application Programe：與操作系統底層無關的所有程式 Middlware是一組提供應用程式開發者額外服務的軟體框架。 Interrupts當 CPU 被中斷時，會將正在執行的程式 transfer 到一個特定的位址，當中斷程式執行完成後，會將原本的程式還原並繼續執行。傳統的 OS 通常會把程式存在固定的位址中，而最近的 OS 則是直接存在 system stack 中。如果 interrupt routine 需要修改暫存器的值的話，則必須先把原本的程式還原，然後再中斷一次。 而負責執行 interrupt 這個動作的程式一般被稱為「interrupt-specific handler」。一般為了能夠快速執行 interrupt，會直接將所有的 interrupt routine 存在一張 table 中。而這張 table 中的位址，皆對應著唯一的 interrupt routine。 Storage Structure在電腦中最基本的單位被稱為 bit。Byte 則是以 8 bit 為一個單位所儲存，通常被用來當做電腦存儲的基本單位。一般的電腦都是一個 byte 在移動資料，而非一個 bit。至於 network 則是一個 bit 在移動，因此在一般換算上才會除 8。"},{"title":"可不可以不要寫糙 code 系列 第 8 篇 - 不必要的註解","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%A6%81%E5%AF%AB%E7%B3%99%20code%20%E7%B3%BB%E5%88%97%20%E7%AC%AC%208%20%E7%AF%87%20-%20%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%A8%BB%E8%A7%A3/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["可不可以不要寫糙 code","/tags/%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%A6%81%E5%AF%AB%E7%B3%99-code/"],["Coding Tips","/tags/Coding-Tips/"]],"categories":[["undefined",""]],"content":"重點 好的程式碼，可以自己解釋自己。 在程式碼中，註解的正確使用方式，是能夠在最關鍵時刻，提供提示的內容。 曝露太多複雜性或細節時，需要有層次感的去表達。用註解來呈現段落感，並不是一個使用註解的好時機，段落感最好的做法，用 function name 取代註解。 「註解會說謊，原始碼不會」 好的註解 《Clean Code》, Ch4 註解，整個章節都在介紹註解。對於不好的註解的介紹有 68~81 頁之多 《The Art of Readable Code》 ,Ch5 認識註解, Ch6 讓註解精確與簡潔。花了兩個章節介紹 《Code Complete 2/e》 ,Ch9 虛擬碼程式設計流程。介紹如何寫完程式碼就擁有良好註解。 《You Don’t Know JS: Up &amp; Going》, Chapter 1: Into Programming, Code Comments。給出了一個簡單的標準: 寫 why 不寫 what，偶爾寫寫 how。 如同 YDKJS 的標準一般: 「寫 why 不寫 what，偶爾寫寫 how。」 PPP 開發法 先寫下你要寫程式的註解 在註解下寫下程式碼 將適合成為 function 的部份歸納成 function 看看有沒有什麼要刪掉的註解 Reference不必要的註解"},{"title":"可不可以不要寫糙 code系列 - 如何寫高品質 function ","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%A6%81%E5%AF%AB%E7%B3%99%20code%E7%B3%BB%E5%88%97%20-%20%E5%A6%82%E4%BD%95%E5%AF%AB%E9%AB%98%E5%93%81%E8%B3%AA%20function/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["可不可以不要寫糙 code","/tags/%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%A6%81%E5%AF%AB%E7%B3%99-code/"],["Coding Tips","/tags/Coding-Tips/"]],"categories":[["undefined",""]],"content":"tags:命名命名的目的，在於「好猜」，看命名就大致可以猜到這 function 在做什麼；反之，命名命得不好，就不好猜。 好的命名規則： 參數設計 全部參數都要用到，不用的參數，就不列出來。 表示函數執行的狀態或錯誤的參數，要放在相同的位置。（通常是最後） 可以的話數量掌握在 7±2 的範圍 Pure function Its return value is the same for the same arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams from I/O devices). Its evaluation has no side effects (no mutation of local static variables, non-local variables, mutable reference arguments or I/O streams function 的輸出永遠只與 function 的輸入相關 (取隨機數就不算 pure ) 沒有 side effects (沒有使用全域變數，或儲存永久變數) 盡可能的讓 getter/setter 寫成 pure function ，將有助於你 debug。這樣的設計，是 flux 在對狀態做更新與取用時，特別要注意的。(ex: vuex 的 mutation, getter) Reference 如何寫高品質 function (命名+參數篇) 如何寫高品質 function (輸出+輸入篇) 如何寫高品質 function (內聚性篇) "},{"title":"必勝 IT 十八招","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E5%BF%85%E5%8B%9D%20IT%20%E5%8D%81%E5%85%AB%E6%8B%9B/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["必勝 IT 十八招","/tags/%E5%BF%85%E5%8B%9D-IT-%E5%8D%81%E5%85%AB%E6%8B%9B/"]],"categories":[["undefined",""]],"content":"如何讓他人主動協助 在剛進一家公司的新人，要找到能夠借的力道，就是所屬單位的同事和主管。當然一定要認清一件事情：沒有人義務可以幫你，所以得先自己想辦法展現出企圖心和上進認真地解決問題，那麼其實當需要幫助的話，同事或是主管都會願意協助。 觀察與保留實力 透過前言基本要訣：「目標、找師父、找大/小公司、勤練、時間管理」等等這些招數之後就可以用客觀的方式來觀察事物，剛開始不要使出全力，透過觀察的方式，去慢慢熟悉每個人的行為和習性與公司環境，保留實力，等遇到問題之後，在看狀況應對和解決問題。 保持無知的自己 唯有虛心接受自己不好的一面，才有突破的空間，保持無知的自己，你才能看到一些不可思議的事情或是有趣的新知。首先要先認清…自己本身還是有學習的地方，不懂的地方很多，努力的去追求更好的解答，讓自己更好，因為培養這樣就會無形慢慢建立誠信，因為擁有誠信，就會吸引一些能力很好的人一起與你共舞。 你服務的對象或是與你互動的同事，他們最希望看到的是專業、誠信的互動，因為當你做到專業與誠信，那自然會吸引一批他們願意相信你的人，所以自然不會失去這群人。 當你透過無知的部分，去學習，相對的別人會跟你請益相關問題的時候，自然你才有辦法引導他人，甚至做到驅動別人改變行為，做一些變革的模式，在資訊業裡頭，最難的就是驅動別人的改變，有時候必要的時候適當的表現無知，自己才能學習更多。 喜歡和合作與信任比專業更重要 你若不是選擇自己喜歡的工作或是感興趣的部分，你會覺得每天過得很痛苦 如果同事之間沒辦法合作，甚至爭鋒相對，你會覺得很阿雜，你會很煩… 信任指的是品牌或商品和商譽的信任和別人對自己的信任。 你要能夠做到表現出「他是值得付出的人，值得自己傻傻願意付出投入的人」。當你願意付出與協助他人或是換位思考的時候，考慮主管或是同事的時候，這時候就會慢慢培養出自己擁有可被信任的人了，那自然就可以借用主管的力，反之主管也會借用你的力，變成合作模式，同時也彼此信任，共同來解決問題，讓大家能夠加薪也能夠工作愉快，這就是尋求雙贏的狀況。 逆向思考 如果要明白人生如何得到幸福，就要先研究人生如何才能變得痛苦；要研究企業如何做強做大，就要先研究企業是如何衰敗的。因為查理．蒙格知道，有時正向思考未必能將我們帶到想去的地方，而逆向思考卻可以。其實上述的方式，就是想知道自己未來會陣亡在什麼地方，這樣未來就不去那啦… Reference必勝 IT 十八招"},{"title":"提升前端 performance 技巧","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%8F%90%E5%8D%87%E5%89%8D%E7%AB%AF%20performance%20%E6%8A%80%E5%B7%A7/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["front-end","/tags/front-end/"]],"categories":[["undefined",""]],"content":"使用者載入網頁後，瀏覽器經過轉譯、繪製才會顯示內容，大致可分為以下流程： Parse Layout Paint Composite Parse載入 HTML 後，瀏覽器會開始進行解析，先將原始的 Response 內容轉換為字串，再利用 Tag 建立 Tokens、Nodes，最終建立 Document Object Model（DOM）： 而解析 HTML 的過程中若遇到 Inline CSS 或是 載入 CSS 檔，就會經過類似的流程建立出 CSS Object Model（CSSOM）： 接著會利用 CSSOM 來算出 DOM 中每一個 Node 的 ComputedStyle，每個 ComputedStyle 都是包含所有 Style property、value 的超大物件，這個過程就是 Recalculate style。 LayoutLayout 階段會把 DOM 轉換為 Layout tree，結構和 DOM 非常像，但不可見的 &lt;script&gt;、&lt;link&gt; 或是加上了 display: none 的 Node 會被排除，而不在 DOM 中的偽元素 ::before、::after 會被加入，建立 Layout tree 的結構（此結構常被稱為 Render tree）。 接著會遍歷 Layout tree 來計算所有 LayoutObject 的位置和大小，根據 LayoutObject 的不同如 LayoutBlock、LayoutInline 等等會有不同的計算方式，其他如字體、Overflow、Scrollbar、float、table、flex 排版、螢幕大小等等位置計算都在此階段完成。 此外在開始 Paint 之前若 LayoutObject 有特定的 Style property 如 transform、will-change 還會另外建立 PaintLayer，而產生 Layer 的過程就是 Update layer tree。 PaintPaint 可分為 Paint 和 Raster 兩個階段。 Paint第一階段並不會真的進行繪製動作，而是先把 Layout tree 轉換為一連串的繪製步驟，其概念和Canvas 非常像，例如「在 (x, y) 座標畫一個長寬為 (w, h) 的紅色長方形」，而一個繪製步驟稱為一個 DisplayItem。 雖然所有 LayoutObject 的位置、大小、樣式都確定了，但因為 Stacking order 的關係（position、z-index 等等影響元素覆蓋關係的 Style），無法遍歷一次 Layout tree 就建立所有 DisplayItem，因此這個階段會依據 Stacking order 多次遍歷 Layout tree 來產生 DisplayItem 陣列（DisplayItemList）。 就結果而言可以想像為將每個 LayoutObejct 轉換為 DisplayItem 後再以 Stacking order 排序，順序規則可以參考 Stacking context。 Raster第二階段就是依據 Update layer tree 建立的 PaintLayer 和所有繪製步驟（DisplayItemList）繪製出多個 Layer，每個 Layer 都是一張點陣圖。 Composite整個 Paint 階段繪製出多個 Layer 後，經由合成器（Compositor）把所有的 Layer 依照順序合併為一張圖，再交由瀏覽器顯示出來。 瀏覽器將多個 Layer 合併為最終結果 回顧順過一次流程後會發現中間還穿插了幾個步驟，因此更完整的 Rendering 流程應該如下： Recalculate Style Layout Update Layer Tree Paint Composite Layers 補充Layers瀏覽器為了提升繪製頁面的效能，會盡可能的利用上次繪製的結果，而 Layer 就是用來降低觸發 Layout、Paint 階段的次數，舉一些實際的例子，將部分內容移到額外的 Layer 後，就能對整個 Layer 加入動畫且不需要重繪該 Layer 的內容。 概覽大部分的瀏覽器會以每秒 60 次的頻率刷新頁面，反過來說只要瀏覽器來不及在 16 毫秒（1000/60）內產出下一個畫面就會讓使用者感覺卡卡的，影響使用體驗。 Rendering 的各個階段： JavaScript – 用 JavaScript 修改 DOM 和 CSS 產生動畫 Style calculations – 計算每個元素的 Computed style Layout – 計算元素的位置、大小 Paint – 將元素的文字、顏色、圖片等等繪製在多個 Layer 上 Compositing – 以正確的順序將 Layers 合併 另外，盡量不要重複讀寫 layout 不斷讀寫穿插的行為會引起效能爆炸，稱為 Layout Thrashing，只進行一次讀取或是把狀態儲存起來可以避免： GIF說到動圖首先想到的就是 GIF，不過 GIF 實在是非常大，不建議直接在網頁中使用，可用 FFmpeg 等工具把 GIF 轉成 MP4 或是 WebM（非常小，不需支援 IE 的首選）。 &lt;video&gt; HTML 的 video 元素加上一些屬性後就能做到：自動開始、循環、無聲、避免全螢幕，和 GIF 沒兩樣，只差在不能直接使用 img 元素。 響應式圖片（Responsive iamges）在 img 加上一些屬性讓瀏覽器依據使用者螢幕大小自動判斷最適合的圖片，保持使用者體驗的同時不浪費流量和效能，例如： Reference How Rendering Works Rendering Optimization Optimize Images "},{"title":"架構","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%9E%B6%E6%A7%8B%E5%B8%AB/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["System Design","/tags/System-Design/"],["講座參與心得","/tags/%E8%AC%9B%E5%BA%A7%E5%8F%83%E8%88%87%E5%BF%83%E5%BE%97/"]],"categories":[["undefined",""]],"content":"前言軟體架構師的定位是什麼？每個人對架構設計的定義是不同的。架構師要傾聽實作架構的人的意見，因為每個人都有盲點。 不存在完美的架構 通常架構師是團隊內最了解技術的人員之一，但就算再有能力，在架構師這個身份時，你一定會碰到很多你不知道的知識，這時候你要在廣度與深度之間抓好比例。 架構師常見問題：你沒有時間去對新技術做大量實作，更常見的是用你過往習慣的技術去處理，但架構師的挑戰不只是技術，甚至還有商業、法律等等。你很難去繼續鑽研深度。成為架構師意味著，你寫程式碼的時間會減少非常多！而且會很常遇到你在工程師時期最討厭的事物，如：參與政治議題、理解商業、理解組織、與他人談判與籌碼交易等等。 架構師與其說是升級，不如說是轉型 架構師應具備的能力 在公司中，你是具有公信力，是大家所信任的人。 在對談需求時，能勇敢說 yes/no。 持續學習與理解新技術，但不要在架構上亂玩新技術。 架構師的第一法則 一切都是取捨 有時不只是深度足夠，更需要取決於技術廣度。 對領域知識也要足夠，架構設計也不是單靠一個人，還需要接觸利害關係人 知道解決方案的差異 分析解決方案的好處與壞處 依據業務需求做出取捨 當你讓架構師做所有決定（如核心、底層），那他有可能就會成為瓶頸。畢竟哪一天他離開了，團隊就沒有人看得懂這套「祖產」aka 技術債 應該是，當架構師決定好架構跟框架，其他讓工程師團隊去負責開發，而架構師頂多在業務相關的程式著手。這就是架構師兼顧技術深度與廣度的方法。 軟體如何解決複雜問題你業務的流程很多，你所屬的業務的概念很多。一環扣著一環，沒有人有辦法單一個人就把解決方案說清楚。每個人看事情的角度不一樣，面對的問題也不一樣，解決問題的方式也不一樣。 我們往往從技術的角度來看事情，而忽略了商業這一塊。但當我們嘗試把商業套用到我們的技術架構時，往往會出問題。但我們很難捨棄商業這一塊，因為「這是我們吃飯的工具」。 提出問題“難於”解決問題作為技術人員，我們已經習慣於作為問題的解決者給出設計方案，而很少以問題提出者的身份去思考設計方案。團隊中常見的典型矛盾，就是產品團隊和研發團隊之間的矛盾。 作為研發團隊，我們常吐槽產品團隊的需求不合理，不懂技術等。其實我們可以試著把自己的工作再往前移一下，不僅僅是去設計架構，實現產品的需求，同時也試著去實現客戶的需求，甚至發現潛在的需求。 這時我們就變成了在設計上提出問題的人，你會發現提出問題的同時，在很多時候也需要同樣深入的思考。設計一個好的問題，甚至比解決問題更難。 其實即便是軟體開發領域的大神 Frederick P. Brooks Jr.（《人月神话》的作者），也會有同樣的感嘆。 “The hardest part of design is deciding what to design.”– 《The design of design》, by Frederick P. Brooks Jr. 決定“不要什麼”比“要什麼”更難也許是由於人性的貪婪，對於軟體系統我們同樣想要更多：「更多功能」、「更好的性能」、「更好的伸縮性」、「擴展性」等等，作為軟體架構師要明白「軟體架構設計就是一種取捨或平衡」。當大家都在往裡面加東西的時候，架構師更應該來做這個說 “不” 的人。 軟體設計和定義過程中存在很多取捨，例如： 完善功能和盡早發布的取捨 伸縮性和性能的取捨 著名的 CAP 原則，就是一個很好的取捨指導策略。為了更好的取捨，保持架構風格的一致性，在一開始架構師就應該根據系統的實際需求來定義一些取捨的原則，如： 數據一致性擁有最高優先級。 提前發布核心功能優於完整發布等。 非功能性需求决定架構因為軟體是為了滿足客戶的功能性需求的，所以很多設計人員可能會認為架構是由要實現的功能性需求決定的。但實際上真正決定軟體架構的其實是「非功能性需求」。 架構師要更加關注非功能性需求，常見的非功能性包括：「性能」，「伸縮性」，「擴展性」和「可維護性」等，甚至還包括團隊技術水平和發布時間要求能實現功能的設計總是有很多，考慮了非功能性需求後才能篩選出最合適的設計。 “簡單”並不“容易”很多架構師都會常常提到保持 simple，但是有時候我們會混淆 simple 和 easy。simple 和 easy 在英語裡也是兩個詞“simple”和“easy”。 “Simple can be harder than complex:You have to work hard to get your thinking clean to make it simple. But it’s worth it in the end because once you get there, you can move mountains.To be truly simple, you have to go really deep.”–SteveJobs 真正的一些簡單的方法其實來自於對問題和技術更深入的理解。這些方案往往不是容易獲得的，表面上的方法。簡單可以說蘊含著一種深入的技巧在其中。 軟體系統的生命週期，有一大半時間都在維護，如何把架構設計的簡單易於維護，並不是一件容易的事情。 溝通的成本 “I believe that the hardest part of software projects, the most common source of project failure, is communication with the customers and users of that software.”–Martin Fowler 正如軟體開發大師 Martin Fowler 提到的“溝通”往往是導致軟體開發失敗的主要原因。 永遠不要停止寫程式架構師也是程式設計師，程式碼是軟體的最終實現形態，停止 coding 會逐漸讓你忘記作為程式設計師的感受，更重要的是忘記其中的“痛”，從而容易產生一些不切實際的設計。 風險優先架構設計很重要的一點是「識別可能存在的風險」，尤其是非功能性需求實現的風險。 因為這些風險往往沒有功能性需求這麼容易在初期被發現，但修正的代價通常要比修正功能性需求大非常多，甚至可能導致整個 project 的失敗，前面我們也提到了非功能性需求決定了架構，如： 數據一致性要求 響應延遲要求 我們應該通過原型或在早期的迭代中確認風險能夠通過合理的架構得以解決。絕對不要把風險放到最後，就算是一個 project 要失敗也要讓它快速失敗，這也是一種敏捷。 從“問題”開始，而不是“技術”技術人員對於新技術的都有著一種與身俱來的激情，總是樂於去學習新技術，同時也更有激情去使用新技術。但是這也同樣容易導致一個通病，就是「當我們有一個錘子的時候看什麼都是釘子」，使用一些不適合的技術去解決手邊的問題，常常會導致簡單的問題複雜化。 我曾經的一個團隊維護過這樣一個簡單的服務，起初就是一個用的 MySQL 作數據存儲的簡單服務，由團隊的一個成員來開發和維護。後來，這位成員對當時新出的 DynamoDB 產生了興趣，並學習了相關知識。然後就發生下面這樣的事： 用DynamoDB替換了MySQL的。 很快發現DynamoDB並不能很好的支持事務特性，在當時只有一個性能極差的客戶端類庫來支持事物，由於採用客戶端方式，引入了大量的額外交互，導致性能差別達7倍之多。這時候，這個同學就採用了當時在NoSQL的領域廣泛流行的最終一致技術，通過一個發布 - 訂閱消息隊列來實現最終一致（即當某對象的值發生改變後會產生一個事件，然後關注這一改變的邏輯，就會訂閱這個通知，並改變於其相關數據，從而實現不同數據的最終一致）。 接著由於DynamoDB無法提供SQL那樣方便的查詢機制，為了實現數據分析就又引入了EMR / MapReduceJob。 到此，大家可以看到實現一樣的功能，但是複雜性大大增加，維護工作也由一個人變成了一個團隊。 過度忙碌使你落後對於IT人而言忙碌已成為了習慣，加班常掛在嘴邊。“996”工作制似乎也變成了公司高效的標誌。而事實上過度的忙碌使你落後。經常遇見一些朋友，在一個公司沒日沒夜的乾了幾年，沒有留一點學習時間給自己。幾年之後倒是對公司越來越“忠誠”了，但忙碌的工作同時也導致了沒有時間更新知識，使得自己已經落後了，連跳槽的能力和勇氣都失去了。 過度忙碌會導致沒有時間學習和更新自己的知識，尤其在這個高速發展的時代我在工作經歷中發現過度繁忙通常會帶來以下問題： 缺乏學習導致工作能力沒有提升，而面對的問題卻變得日益複雜。 技術和業務上沒有更大的領先優勢，只能被動緊緊追趕。試想一下，要是你都領先同行業五年了，還會在乎通過加班來早一個月發布嗎？ 反過來上面這些問題會導致你更加繁忙，進而更沒有時間提高自己的技術技能，很快就形成了一個惡性循環。 練過健身的朋友都知道，光靠鍛煉是不行的，營養補充和鍛煉同樣重要。個人技術成長其實也一樣，實踐和學習是一樣重要的，當你在一個領域工作了一段時間以後，「工作對你而言就主要是實踐了，隨著你對該領域的熟悉，能學習的到技術會越來越少。」，所以每個技術人員都要保證充足的學習時間，否則很容易成為井底之蛙，從而陷入前面提到的惡性循環。 最後，以偉大詩人屈原的詩句和大家共勉： “路漫漫其修遠兮，吾將上下而求索” 希望我們大家都可以不忘初心，保持匠心！ 實際案例 Impact MappingGoal -&gt; Who -&gt; What -&gt; How 從中找到 User Story，客戶小明（who），為了更方便的進行購物（how），我想要線上下單（what）。 User Story Mapping Specification by ExampleUbiquitous Language: 不只是專有名詞文件化，更是所有人的一個共識，並落實到程式碼、測試、文件、溝通之中。例如：網頁最下面的區塊名稱，所有人一致認為要稱為「footer」，那文件中，就要根據 footer 為名稱主軸進行撰寫，而程式碼也是，如：view_footer.html。 如何進行 Ubiquitous Language 的建構： PO（PM）透過 User Story 告訴團隊需求故事。 團隊每個人寫下自己的想法，與針對該需求的案例，向 PO（PM）與團隊其他成員確認彼此對需求的認知是否一致。 整理、歸納，並將寫下的例子，整理成文件。 是測試案例也是需求規格 文件放置在所有人都能夠存取到的地方。 持續重構與整理文件。 需求規格成果： 很多開發團隊不知道測試團隊要測試什麼，而 QA 也不知道 dev 如何寫程式。 dev 會用自己認知的開發規格去寫程式，這時就很容易出現 bug 找出領域概念比如，找出業務活動中名詞與動詞。 目前國外流行的兩種方法： Event Storming () Domain Storytelling () 台灣 DST 大神演講： 定義問題與解決方案 第三方支付可能會發生很多問題(外部問題、網路問題、安全性….)： 設計架構時，可以把外部金流的風險獨立出來成一個解決方案 再者，我們可能也不會只用一家金流，可能會需要建立一些重用的元件。 那我們應該怎麼做選擇呢？回頭前面，從架構特性開始看起。 持續改善架構設計DDD 有助於持續改善架構設計 寫程式的技巧在於「高內聚、低耦合」。但是，資料庫是一個很容易把相應的服務給綁住的耦合原件。 同步/非同步共生性 同步：[order service] &lt;- req/resp -&gt; [payment system] 訂單/金流服務藕合性較高，互為影響，採用同歩需要較多考量 非同步[order service] &lt;- event -&gt; (= 事件通道 =) &lt;- event-&gt; [payment system] 可能遇到 Primary Key, Foreign Key 難以同步等技術困難。 持續改善架構設計資料庫依模組切離，減少耦合性 為了應付更複雜的業務場景，架構再一次演進: Mediator Pattern，讓服務之間不互相依賴 但缺點是架構變得更複雜，比如當一個地方出錯，你會需要更多機制去 debug，難度會比上一個架構難上更多。 不同的架構風格有不同優點與風險，架構師此時就是要讓團隊理解這項決定帶來的改變。商業模式、技術模式的改變，優缺點會一直改變。 其他重要的 投資基礎工程實務不可以省，開發主管不管如何都應該撥出時間去處理 Test (unit, integrated, e2e) CI/CD Infra as code Reference 架构师 2021-05-22 技術管理者論壇 Session 2 - 商業與技術的平衡 "},{"title":"正規表示法（Regular Expression, Regex）- 分組捕捉","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88Regular%20Expression,%20Regex%EF%BC%89-%20%E5%88%86%E7%B5%84%E6%8D%95%E6%8D%89/","tags":[["Regex","/tags/Regex/"]],"categories":[["undefined",""]],"content":"可以使用 () 來將規則表示式分組，除了作為子規則表示式之外，還可以搭配量詞使用。 例如想要驗證電子郵件格式，允許的使用者名稱開頭要是大小寫英文字元，之後可搭配數字，規則表示式可以寫為 ^[a-zA-Z]+\\d，因為 @ 後網域名稱可以有數層，必須是大小寫英文字元或數字，規則表示式可以寫為 ([a-zA-Z0-9]+.)+，其中使用 () 群組了規則表示式，之後的 + 表示這個群組的表示式符合一次或多次，最後要是 com 結尾，整個結合起來的規則表示式就是 ^[a-zA-Z]+\\d@([a-zA-Z0-9]+\\.)+com。 若有字串符合了被分組的規則表示式，字串會被捕捉（Capture），以便在稍後回頭參考（Back reference），在這之前，必須知道分組計數，如果有個規則表示式 ((A)(B(C)))，其中有四個分組，這是遇到的左括號來計數，所以四個分組分別是： ((A)(B(C))) (A) (B(C)) (C)分組回頭參考時，是在 \\ 後加上分組計數，表示參考第幾個分組的比對結果。 例如，\\d\\d 要求比對兩個數字，(\\d\\d)\\1 的話，表示要輸入四個數字，輸入的前兩個數字與後兩個數字必須相同，例如輸入 1212 會符合，12 因為符合 (\\d\\d) 而被捕捉至分組 1，\\1要求接下來輸入也要是分組 1 的內容，也就是 12；若輸入 1234 則不符合，因為 12 雖然符合 (\\d\\d) 而被捕捉，然而 \\1 要求接下來的輸入也要是 12，然而接下來的數字是 34，因而不符合。 再來看個實用的例子，[“‘][^”‘]*[“‘] 比對單引號或雙引號中 0 或多個字元，但沒有比對兩個都要是單引號或雙引號，([“‘])[^”‘]*\\1 則比對出前後引號必須一致。 規則表示式中的 (?…) 代表擴充標記（Extension notation），括號中首個字元必須是?，而這之後的字元（也就是…的部份），進一步決定了規則表示式的組成意義。 如果不需要分組計數，只是想使用 () 來定義某個子規則，可以使用 (?:…) 來表示不捕捉分組。 例如，若只是想比對郵件位址格式，不打算捕捉分組，可以使用 ^[a-zA-Z]+\\d*@(?:[a-zA-Z0-9]+.)+com。在規則表示式複雜之時，善用 (?:…) 來避免不必要的捕捉分組，對於效能也會有很大的改進。 如果想比對出的對象，之後必須跟隨或沒有跟隨著特定文字，可以使用 (?=…) 或 (?!…)，分別稱為 lookahead 與 negative lookahead。例如分別比對出來的名稱最後必須有 Lin： 分組捕捉如果將上圖中的 (?=Lin) 改為 (?!Lin)，就會比對出 Monica。 相對地，如果想比對出的對象，前面必須有或沒有著特定文字，可以使用 (?&lt;=…) 或 (?&lt;!…)，分別稱為 lookbehind 與 negative lookbehind。 Reference Openhome - 分組捕捉 "},{"title":"正規表示法（Regular Expression, Regex）- 字元、字元類","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88Regular%20Expression,%20Regex%EF%BC%89-%20%E5%AD%97%E5%85%83%E3%80%81%E5%AD%97%E5%85%83%E9%A1%9E/","tags":[["Regex","/tags/Regex/"]],"categories":[["undefined",""]],"content":"規則表示式中的兩類基本字元符號為「字面字元（Literals）」與「詮譯字元（Metacharacters）」。 字面字元是指按照字面意義比對的字元，例如指定 Orz 時，指的是三個字元 O、r、z 連續出現的規則；詮譯字元是不按照字面比對，在不同情境有不同意義的字元。 例如 ^ 是詮譯字元，規則表示式 ^Orz 是指行首後接續出現 Orz 的規則，也就是此時 ^ 表示一行的開頭，而不是比對 ^ 這個字元；但是規則表示式 [^Orz] 用來表示指不包括 O 或 r 或 z，也就是在 [] 中時，^ 表示非之後幾個字元之一的情況。 字面字元 效果 Orz 三個字元 O、r、z 連續出現的字串才符合條件 詮譯字元 效果 [^Orz] 用來表示指不包括 O 或 r 或 z，也就是在 [] 中時，^ 表示非之後幾個字元之一的情況 詮譯字元在規則表示式中有特殊意義，例如： $ ^ * ( ) + = &#123; &#125; [ ] | \\ : . ? 等，若要比對這些字元，則必須加上轉義（Escape）符號，例如要比對 $ 字元，必須使用 \\$。如果不確定哪些標點符號字元要加上轉義符號，可以在每個標點符號前加上\\，例如比對逗號也可以寫 \\,。 如果規則表示式為 XY，那麼表示比對「X 之後要跟隨著 Y」，如果想表示「X 或 Y」，可以使用 X|Y，如果有多個字元要以「或」的方式表示，例如「X 或 Y 或 Z」，可以使用字元類（Character class）表示為 [XYZ]。 規則表示式中，多個字元可以歸類在一起，成為一個字元類，字元類會比對文字中是否有「任一個」字元符合字元類中某個字元。規則表示式中被放在[]中的字元就成為一個字元類。例如，若字串為 Justin1Monica2Irene3Bush，你想要找到 1 或 2 或 3 來切割字串，規則表示式可撰寫為 [123]。 規則表示式 123 連續出現字元 1、2、3，然而 [] 中的字元是「或」的概念，也就是 [123] 表示「1 或 2 或 3」，| 在字元類別只是個普通字元，不會被當作「或」來表示。 字元類中可以使用連字號-作為字元類詮譯字元，表示一段文字範圍，例如要比對文字中是否有 1 到 5 任一數字出現，規則表示式為 [1-5]，要比對文字中是否有 a 到 z 任一字母出現，規則表示式為 [a-z]，要比對文字中是否有 1 到 5、a 到 z、M 到 W 任一字元出現，規則表示式可以寫為 [1-5a-zM-W]。 字元類中可以使用 ^ 作為字元類詮譯字元，[^] 則為反字元類（Negated character class），例如 [^abc] 會比對 a、b、c 以外的字元。 以下為字元類的幾個表示範例： Regex 效果 [abc] a 或 b 或 c 任一字元 [^abc] a、b、c 以外的任一字元 [a-zA-Z] a 到 z 或 A 到 Z 任一字元 [a-d[m-p]] a 到 d 或 m 到 p 任一字元（聯集），等於 [a-dm-p] [a-z&amp;&amp;[def]] a 到 z 且是 d、e、f 的任一字元（交集），等於 [def] [a-z&amp;&amp;[^bc]] a 到 z 且不是 b 或 c 的任一字元（減集），等於 [ad-z] [a-z&amp;&amp;[^m-p]] a 到 z 且不是 m 到 p 的任一字元，等於 [a-lq-z] 有些字元類很常用，例如經常會比對是否為 0 到 9 的數字，可以撰寫為 [0-9]，或是撰寫為 \\d，這類字元被稱為字元類縮寫或預定義字元類（Predefined character class），它們不用被包括在 [] 之中，底下列出可用的預定義字元類： Regex 效果 . 任一字元（不包括換行、多位元組字元） \\d 比對任一數字字元，即 [0-9] \\D 比對任一非數字字元，即 [^0-9] \\s 比對任一空白字元，即 [\\t\\n\\x0B\\f\\r] \\S 比對任一非空白字元，即 [^\\s] \\w 比對任一 ASCII 字元，即 [a-zA-Z0-9_] \\W 比對任一非 ASCII 字元，即 [^\\w] Reference Openhome - 字元、字元類 "},{"title":"正規表示法（Regular Expression, Regex）- 總表","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88Regular%20Expression,%20Regex%EF%BC%89-%20%E7%B8%BD%E8%A1%A8/","tags":[["Regex","/tags/Regex/"]],"categories":[["undefined",""]],"content":" Regex 效果 . 任一字元（不包括換行、多位元組字元） \\d 比對任一數字字元，即 [0-9] \\D 比對任一非數字字元，即 [^0-9] \\s 比對任一空白字元，即 [\\t\\n\\x0B\\f\\r] \\S 比對任一非空白字元，即 [^\\s] \\w 比對任一 ASCII 字元，即 [a-zA-Z0-9_] \\W 比對任一非 ASCII 字元，即 [^\\w] Regex 效果 X? X 項目出現一次或沒有 X* X 項目出現零次或多次 X+ X 項目出現一次或多次 X&#123;n&#125; X 項目出現 n 次 X&#123;n,&#125; X 項目至少出現 n 次 X&#123;n,m&#125; X 項目出現 n 次但不超過 m 次 Regex 效果 ^ 一行開頭 $ 一行結尾 \\b 單字邊界 \\B 非單字邊界 \\A 輸入開頭 \\G 前一個符合項目結尾 \\Z 非最後終端機（final terminator）的輸入結尾 \\z 輸入結尾 "},{"title":"正規表示法（Regular Expression, Regex）- 量詞、錨點","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88Regular%20Expression,%20Regex%EF%BC%89-%20%E9%87%8F%E8%A9%9E%E3%80%81%E9%8C%A8%E9%BB%9E/","tags":[["Regex","/tags/Regex/"]],"categories":[["undefined",""]],"content":"如果想使用者輸入的手機號碼格式是否為 XXXX-XXXXXXX，其中 X 為數字，雖然規則表示式可以使用 \\d\\d\\d\\d-\\d\\d\\d\\d\\d\\d，不過更簡單的寫法是 \\d{4}-\\d{6}，{n} 是貪婪量詞（Greedy quantifier）表示法的一種，表示前面的項目出現 n 次。 底下列出可用的貪婪量詞： Regex 效果 X? X 項目出現一次或沒有 X* X 項目出現零次或多次 X+ X 項目出現一次或多次 X&#123;n&#125; X 項目出現 n 次 X&#123;n,&#125; X 項目至少出現 n 次 X&#123;n,m&#125; X 項目出現 n 次但不超過 m 次 貪婪量詞之所以貪婪，是因為看到貪婪量詞時，比對器（Matcher）會把符合量詞的文字全部吃掉，再逐步吐出（back-off）文字，看看是否符合貪婪量詞後的規則表示式，如果吐出的部份也符合就比對成功。 簡單來說，貪婪量詞會儘可能地找出長度最長的符合文字。 例如文字 xfooxxxxxxfoo，若使用規則表示式 .*foo 比對，比較器根據 .* 吃掉了整個 xfooxxxxxxfoo，之後吐出 foo 符合 foo 部份，得到的符合字串就是整個 xfooxxxxxxfoo。 若在貪婪量詞表示法後加上?，會成為逐步量詞（Reluctant quantifier），又常稱為懶惰量詞，或非貪婪（non-greedy）量詞（相對於貪婪量詞來說），比對器是一邊吃一邊比對文字是否符合量詞與之後的規則表示式。 簡單來說，逐步量詞會儘可能地找出長度最短的符合文字。 例如文字 xfooxxxxxxfoo 若用規則表示式 .*?foo 比對，比對器在吃掉 xfoo 後發現符合 .*? 與 foo，接著繼續吃掉 xxxxxxfoo 發現符合 .*? 與 foo，得到 xfoo 與 xxxxxxfoo 兩個符合文字。 有些工具或語言支援獨吐量詞（Possessive quantifier），例如 Java（然而 Python、JavaScript 不支援），也就是在貪婪量詞表示法後加上 +，比對器會將符合量詞的文字全部吃掉，而且不再回吐（因此才稱為獨吐）。 例如文字 xfooxxxxxxfoo，若使用規則表示式 x*+foo 比對，x 符合 x*+ 被吃了，後續 foo 符合 foo，得到 xfoo 符合，接著 xxxxxx 符合 x*+ 被吃了，後續 foo 符合 foo，得到 xxxxxxfoo 符合。 文字 xfooxxxxxxfoo，若使用規則表示式 .*+foo 比對，整個 xfooxxxxxxfoo 會因符合 .*+ 全被比對器吃了，沒有文字可再用於比對 foo，結果就是沒有任何文字符合。 如果有個文字 Justin dog Monica doggie Irene，使用表示式 dog 的話，會符合到 dog 與 doggie 前的 dog 部份： 量詞、錨點你可以使用 \\b 標出單字邊界，例如 \\bdog\\b，這就只會比對出 dog 單字： 量詞、錨點邊界比對用來表示文字必須符合指定的邊界條件，也就是定位點，因此這類表示式也常稱為錨點（Anchor），底下列出規則表示式中可用的邊界比對： Regex 效果 ^ 一行開頭 $ 一行結尾 \\b 單字邊界 \\B 非單字邊界 \\A 輸入開頭 \\G 前一個符合項目結尾 \\Z 非最後終端機（final terminator）的輸入結尾 \\z 輸入結尾 Reference Openhome - 量詞、錨點 "},{"title":"測試的道理","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E6%B8%AC%E8%A9%A6%E7%9A%84%E9%81%93%E7%90%86/","tags":[["当然我在扯淡","/tags/%E5%BD%93%E7%84%B6%E6%88%91%E5%9C%A8%E6%89%AF%E6%B7%A1/"],["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"]],"categories":[["undefined",""]],"content":" 不要以為你處處顯示出「重視程式碼質量」的態度，就能提高程式碼的質量。光有態度和口號是不解決問題的，程式碼的質量不會因為你重視它就得到提升，也不會因為你採取了措施（比如測試，靜態分析）就一定會得到改善。 在程式和演算法定型之前，不要寫測試。過早的測試會導致工作變得複雜，無法寫出優雅的程式碼，只有在程式不再需要大幅度改動之後，才是逐漸加入測試的時候。 不要為了寫測試而改變本來清晰簡單的寫程式方式。 不要測試「實現細節」，因為那等同於寫了兩遍同樣的程式碼。測試應該只需要滿足基本的性質，如：「sqrt（4）應該等於 2」，而不是去測試具體的平方算法步驟。 並不是每修復一個 bug 就要寫測試，假設這個 bug 很簡單，只要修復了就不可能在出現的情況下，多寫測試反而是減慢工作進度。 只有當現有的測試沒有抓住程式必須滿足的重要性質時，才需要寫測試。 避免使用 mock，特別是多層的 mock。你只需要為每一個 module 準備一些輸入（包括邊界情況），確保它們的輸出符合要求。然後你把這些 module 像 pipe 一樣連接起來，形成一個更大的module，測試它是否符合輸入輸出要求，不需要做多層的 mock。 「不要過分重視自動化測試，人工測試也是測試。」，過分的重視測試自動化的原因，往往在於一個不切實際的假設，他們假設錯誤會頻繁的再次發生，所以自動化了可以省下人的力氣。但是其實，一旦一個 bug 被修好，它反復出現的機會不會很大的。過分的要求測試自動化，不但延緩了工程進度，讓程式設計師惱火，效率低下，而且失去了人工測試的精確性。 「避免寫太長，太耗時的測試。」，本來用很小的輸入就可以測試到需要的性質，有人卻總喜歡給一個很大的輸入，下意識的以為這樣更加靠譜，結果這測試每次都會消耗大量的build 時間，而其實達到的效果跟很小的輸入沒有任何區別。 「一個測試只測試一個方面，避免重複測試。」，如果一個測試只測一個方面，不重複測同一個部分，那麼你就可以很快的根據失敗的測試，發現出問題的部分和位置。 避免通過比較字串來進行測試。這種測試是非常脆弱的，很容易因為微小的改動而使大量測試失敗，導致很多的測試需要做不必要的修改。正確的做法，應該是進行結構化的比較，如果你要把標準結果存成 JSON，那麼你應該先 parse 出 JSON 所表示的對象，然後再進行結構化的對比。 「測試並不能幫助後人」。如果你的程式碼寫得很亂，就算你測試在多，後人無法理解，甚至會不知道到底是程式碼本身有問題，還是測試有問題。無論如何，後人都必須先理解原本的程式碼邏輯，知道它在做什麼，否則不可能做出正確的修改，就算你有再嚴密的測試也一樣。 測試不能保証程式碼完全不被改錯，實際上它們防止程式碼被改錯的作用力是非常弱的。 Reference测试的道理"},{"title":"當然我在扯淡的教誨","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E7%95%B6%E7%84%B6%E6%88%91%E5%9C%A8%E6%89%AF%E6%B7%A1%E7%9A%84%E6%95%99%E8%AA%A8/","tags":[["当然我在扯淡","/tags/%E5%BD%93%E7%84%B6%E6%88%91%E5%9C%A8%E6%89%AF%E6%B7%A1/"],["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"]],"categories":[["undefined",""]],"content":" 使用者也是系統的模組 一個好的工具，應該只有少數幾條需要記憶的規則 學習計算機（或者任何其它工具），應該「只選對的，不選難的」記憶一堆的命令，烏七八糟的工具用法，最後腦子裡什麼也不會留下。學習原理性的東西，才是永遠不會過時的。 去除頭腦裡的宗教，偏激，仇恨和鄙視。每次仇恨一個東西，你就失去了向它學習的機會。 在腳本裡面盡可能的使用通常的程式設計原則。 不要為了縮短程式碼，而減少可讀性 很多問題的”存在”，其實是因為人們的”固定思維”，他們看不到問題的”根源”和”因果關係”，經常假設某種”先決條件”（A）的存在，然後堅定不移地相信由此”導致”的問題（B）的存在，如下圖： A —–&gt; B但其實只要解決 A，就不存在 B 的問題了。 古老而美麗的理念，也許能夠給予思想的啟迪，可是未必就能在工程中達成理想的效果。 測試的建構，應該是在程式主體已經成形的情況下才能進行。如果程式屬於創造性的設計，主體尚未成形，過早加入的測試反而會大幅度的降低開發效率。 沒有任何一種程式語言值得你用畢生的精力去”精通”它，”精通”其實代表著”腦殘”。 每個人都應該學習多種程式語言，這樣才不會讓自己的思想受到單一語言的約束，而沒辦法接受新的，更加先進的思想。這就像每個人都應該學至少一種外語一樣，否則你就會身陷在自己民族的思維方式中，有時候民族傳統的思想會讓你深陷無須有的痛苦卻無法自拔。 程式語言並不是工具，而是一種材料，工具應該是指 IDE 或文字編輯器。自己寫的程式最後會成為產品的一部份，針對適當的產品（應用）使用適當的材料（程式語言）。 大部分的教育過於重視在”證明”，卻忽略了比證明更重要的東西–”原因”。如果只知道證明而不去思考它背後的原因，到最後只會被困在他人的理論中，而無法舉一反三。 跟真正的大師學習，而不是跟他們的徒弟。如果你真的要學一個演算法，就應該直接去讀那演算法的發明者的論文，而不是轉述過來的「二手知識」。二手的知識往往把發明者原來的動機和思路都給去掉了， 只留下蒼白無味，沒有什麼啟發意義的“最後結果”。 不要因為名氣，而忽視掉真正重視你的人。 不要”以難為豪”，很多人誤以為打字的快，程式就寫得好。掌握整體的 Picture，而不是去記一些奇怪的東西。 讓一個人去修他人的 BUG 是”效率十分低”的作法，每個人都有自己的 coding style 和思維，強破一個人去理解他人的思維是有問題的，特別是製造 BUG 的那個人的思維是個屎。最好的方法是讓他自己去改，直到他覺得有問題來問你時，在跟他解釋你的想法。 所謂「物件導向語言」，其實就是就是加了一點抽象能力（class, object）的 Procedural programming。它本質上是一個 map。物件導向的思想本身是好的，但把每個 function 都視為是物件的一部份，導致原本 functional programing 就能做到的事情，變得必須拐好幾個彎才能做到，如：Design Pattern。 再高明的方法論，也無法代替真正的、精華的計算機科學教育。 「避免重複」並不等於「抽象」。 有時候適當的重複程式碼是有好處的，防止過早抽象的方法叫做「等待」，過早的提出抽象，很可能到後來才發現它們的行為其實是完全不同的，會造成綁手綁腳的結果。如果程式碼只重複使用兩次，也不要提前抽出來，因為它可能只用那麼兩次。 在程式和演算法定型之前，不要寫測試。過早的測試會導致工作變得複雜，無法寫出優雅的程式碼，只有在程式不再需要大幅度改動之後，才是逐漸加入測試的時候。 「一個測試只測試一個方面，避免重複測試。」，如果一個測試只測一個方面，不重複測同一個部分，那麼你就可以很快的根據失敗的測試，發現出問題的部分和位置。 人們常說，程式碼讀的時候比寫的時候多得多，所以要想語言好用省事，我們應該更加重視讀的時候，而不是寫的時候。 洞察力是透過現象看到本質的能力，有洞察力的人很容易得到經驗，然而有經驗的人卻不一定擁有洞察力（盲目）。 在當 PM 時應該先解釋為什麼要做這件事，它的重要性，這樣才能讓人理解，才能尊重工程師的智商。 公司裡自然有不同水平的人，雜事一般都應該交給水平比較低的，或者剛畢業的新手去搗鼓，或者正好有人感興趣，那當然最好。當然對於新手我們也應該尊重，如果他折騰了一段時間，跟你反映這個東西問題太多不好用，你就應該考慮放棄這個東西，也許有其它更好的選擇。 高薪不一定能請到高手，但低薪一定會請到猴子。盡量善待高手，讓他在他所擅長的領域發揮。 其實 IT 界沒這麼多「領域」，每一個領域需要的知識，不過都是計算機科學：資料結構，演算法，程式語言，再加上一點工程經驗。 事物和技術並沒有新舊之分，只有合理與不合理的差別。 不要加入可有可無的功能，而損害關鍵功能的可靠性。 盡量不要去動 legacy code，因為它是前人所留下來的智慧結晶，即便它很醜，但卻也是經過現實的淬鍊。如果直接把 legacy code 砍掉重練，通常很難復原它的效果，反而會製造出更多的 bug ，因為前人所踩的坑，我們不見得可以完全掌握。 對待 legacy code 的方式是，盡量讓自己的程式碼可以在 legacy code 中替換與更改。在不動到原本架構的情況下解決 bug。如果是 legacy code 本身引發的問題，就一小部分一小部分的慢慢去更改，逐漸將它轉換成自己的邏輯，並確定不失去原始程式碼語意的情況下修改它。 看書的時候要廣度搜尋，每個問題每本書的作者對它的見解深度都是不同的，有些時候經典教材其實只是出版的早，有些問題其實作者自己也沒有看透。因此，看書不要從頭看到尾，如果有一個主題看得你很痛苦，你應該去尋找其他更好理解的資源(身邊的他人、網路文章、其他書籍等等)。 不要片面看中文的文章，也應該搜尋與它相關的其他語言文章，來進行各種資料的對比，這樣更容易得到準確的訊息。 先有想法（演算法），才有程式碼。程式碼不能清晰表達一個人的思想，與其看人家的程式碼，不如直接問他的想法。不要對他人說”自己去看程式碼”，沒有人應該被迫去閱讀其他人的程式碼，寫出程式碼的人有義務講清楚自己程式碼背後的想法。 程式碼與成果都是可以白嫖的。但一個人的想法可以從對話中得出那個人的斤兩。 所謂的「成功」是決定在自己而非他人，做自己想做的，吸引認同自己，尊重自己的人，而不是一群勢利的賤人。 一個企業如果出現這種不尊重他人，且以居高臨下的方式命令他人的現象，不管他的地位如何，這皆會導致提拔奸人，流失人才，決策錯誤，導致企業走向末路。應該從制度上防止這種現象的發生，進行反對這種風氣的宣傳和講座，制定相應的規章制度，給員工提供方便而私密的渠道越級匯報這種問題。管理者應該請存在這種問題的員工談話，加以警告，要求他們改變態度，告訴他們公司不容忍這種現象。這樣主動預防，形成良好的文化，成為大家喜歡工作的地方。 想要嚴肅地學習任何領域，都應該選擇質量過關的裝備。如果選擇品質次要或是太差的，很可能因為體驗太差導致失去興趣，甚至放棄學習。如果覺得貴，可以一次只購買一小部分來嘗試，等學習到一個段落以後，再使用較便宜的裝備。如果沒啥太大的差別，就可以用比較便宜的，如果不習慣用便宜的，再換回貴的就好了。 一個完全沒有摸到門路的人，是沒有資格給出他人「做到極致」的評價的，因為他根本不知道「極致」是什麼。日本人並沒有把事情做到極致，而只是摸到了正確的門路，不斷改進。只要方向正確，就會比瞎蒙亂撞，不用心，裝模作樣的人強很多了，以至於這些人認為日本人已經做到了「極致」。人所關心的事情，不應該是做到極致，而應該是真心做事，摸到正確的門路，不要完全走錯了方向。 "},{"title":"編程的智慧","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E7%B7%A8%E7%A8%8B%E7%9A%84%E6%99%BA%E6%85%A7/","tags":[["当然我在扯淡","/tags/%E5%BD%93%E7%84%B6%E6%88%91%E5%9C%A8%E6%89%AF%E6%B7%A1/"],["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["Coding Tips","/tags/Coding-Tips/"]],"categories":[["undefined",""]],"content":"[toc] 反覆思考程式碼 看一位作家的水平，不是看他發表了多少文字，而要看他扔掉了多少稿紙。 寫程式也是一樣的概念。好的程式設計師，會反覆的 review 自己的程式碼。就像文學作品一樣，程式碼不可能一氣呵成，靈感總是零零星星陸陸續續的到來。再厲害的程式設計師，也需要經過一段時間，才能發現最簡單優雅的寫法。有時候你反復修改了程式碼，發現以為已經沒啥好改的，但放著過幾個月再回來看，你總能發現一些可以改進的地方。 所以如果反復修改程式碼已經不再有進展，那麼你可以暫時把它放下。過幾個星期或者幾個月再回頭來看，也許就有煥然一新的靈感。 這樣反反復復很多次之後，你就積累起了靈感和智慧，從而能夠在遇到新問題的時候直接朝正確，或者接近正確的方向前進。 寫優雅的程式碼優雅的程式碼有一個特徵是，它的邏輯大體上看起來，是分明的樹狀結構（tree）。 這是因為程式所做的幾乎一切事情，都是訊息的傳遞和分支。你可以把程式碼看成是一個電路，電流經過導線，分流或者匯合。 如果你是這樣思考的，你的程式碼裡就會比較少出現只有一個分支的 if 語句，它看起來就會像這個樣子： else 裡面可能會出現少量重複的程式碼，但這樣的結構，邏輯卻非常緊密清晰。使用這種形式，可以避免漏掉 corner case。不要讓你的 control flow 往下掉。 寫模組化的程式碼真正的模組化，並不是文字語意上的，而是邏輯層面上的。一個模組應該像電路晶片一樣，他有定義良好的輸入和輸出。實際上一種很好的模組化方法叫做「function（函式）」，每一個 function 都有明確的輸入（參數）和輸出（返回值），同一個文件可以包含多個 function。因此，沒有必要把程式碼分開放在多個文件或者目錄裡面，同樣也可以完成模組化。 良好的模組化條件： 避免寫太過長的 function。 製造小的通用 function - 如果發現其他 function 有重複的程式碼，可以把它提出來變成獨立的 function。 每個 function 只做一件簡單的事情。 避免使用 global variable 和 class member 來傳遞訊息，盡量使用 local variable 和 parameter。 不好的例子 首先，findX()，把一個值寫入成員 x。 然後，使用 x 的值。 這樣，x 就變成了 findX 和 print 之間的數據通道。 由於 x 屬於 class A，這樣程式就失去了模組化的結構。由於這兩個 function 依賴於 x，它們不再有明確的輸入和輸出，而是依賴 local data。findX 和foo 不再能夠離開 class A 而存在，而且由於 class member 還有可能被其他程式碼改變，程式碼變得難以理解，難以確保正確性。 好的例子 寫可讀的程式碼 少寫註解，盡量讓程式碼去解釋自己的行為。寫 why，不寫 what，偶爾寫寫 How。 有意義的命名 function 和 variable。 Local variable 應該盡量接近他使用的地方。 不好的例子 由於中間都沒使用過 index，也沒有改變他的值，所以其實這個 variable，可以挪到接近使用它的地方。 好的例子 Local variable 名子應該要簡短，配合上第二點可以使你的程式碼更具有解釋性。 不要重複使用 local variable，盡量讓它的作用域減少不必要的增大。 複雜的邏輯要提出去，讓程式碼變得簡短好懂。 把複雜的表達式提出去。 在合理的地方進行換行。 寫簡單的程式碼 並不是程式語言提供什麼，你就一定要用上它。 避免使用 i++, ++i, i--, --i，使用的情況應該侷限於迴圈和只有它自己是單獨一行的情況下。 永遠不要省略括號 避免使用 continue 和 break，會造成迴圈的邏輯和終止條件變得複雜，難以確保正確。 如果出現了 continue，把 continue 的條件反向，就可以消除 continue。 如果出現了 break，把 break 的條件，合併到迴圈頂部的終止條件裡，從而去掉break。 有時候你可以把 break 替換成 return，從而去掉 break。 如果以上都失敗了，可以把迴圈中較複雜的部份提取出來，做成 function 減少複雜度，之後 continue 和 break 都可以去掉了。 正確處理錯誤錯誤處理是一個古老的問題，可是經過了幾十年，還是很多人沒搞明白。Unix 的系統 API 手冊，一般都會告訴你可能出現的返回值和錯誤訊息。 比如，Linux 的 read 系統調用手冊裡面有如下內容： 很多初學者，都會忘記檢查 read 的返回值是否為-1，覺得每次調用 read 都得檢查返回值很繁瑣，不檢查貌似也相安無事。這種想法其實是很危險的。 如果函數的返回值告訴你，要碼返回一個正數，表示讀到的數據長度，要碼返回 -1，那麼你就必須要對這個 -1 作出相應的，有意義的處理。千萬不要以為你可以忽視這個特殊的返回值，因為它是一種“可能性”。程式碼漏掉任何一種可能出現的情況，都可能產生意想不到的災難性結果。 另外，try catch 裡面，應該只包含少量的程式碼。比如，如果 foo 和 bar 都有可能發生 異常 A，明確分辨是哪一個 function 出了錯，可以大大減少你 debug 的時間。 正確處理 null 指標Null 其實根本不是一個合法的對象。它不是一個 String，不是一個 Integer，也不是一個自定義的 class。null 的類型本來應該是 NULL，也就是 null 自己。根據這個基本觀點，我們推導出以下原則： 盡量不要產生 null 指標 盡量不要使用 null 來初始化變數 函數盡量不要返回 null，如果你要表達「沒有、出錯了」的結果，盡量使用 Java 的 exception 機制。 其實「沒有」和「出錯了」是兩件完全不同的事情，用 null 來表示「出錯了」是種誤用，出錯的時候應該拋出 exception 而不是 null。 防止過度工程 先把眼前的問題解決掉，解決好，再考慮將來的擴展問題。 先寫出可用的程式碼，反复推敲，再考慮是否需要重用的問題。 先寫出可用，簡單，明顯沒有 bug 的程式碼，再考慮測試的問題。 過度工程即將出現的一個重要訊號，就是當你過度的思考“將來”，考慮一些還沒有發生的事情，還沒有出現的需求。比如： 如果我們將來有了上百萬行程式碼，有了幾千名員工，這樣的工具就不夠用了 將來我可能需要這個功能，所以我現在就把程式碼寫來放在那裡 將來很多人要擴充這片程式碼，所以現在我們就讓它變得可重用 這就是為什麼很多軟體專案如此復雜，實際上沒做多少事情，卻為了所謂的“將來”，加入了很多不必要的複雜性。眼前的問題還沒解決，就被“將來”給拖垮了。人們都不喜歡目光短淺的人，然而在現實的工程中，有時候你就是得看近一點，把手頭的問題先搞定了，再談以後擴展的問題。 另外一種過度工程的來源，是過度的關心“程式碼重用”。很多人“可用”的程式碼還沒寫出來，就在關心“重用”。為了讓程式碼可以重用，最後被自己搞出來的各種框架捆住手腳，最後連可用的程式碼就沒寫好。如果可用的程式碼都寫不好，又何談重用呢？很多一開頭就考慮太多重用的工程，到後來被人完全拋棄，沒人用了，因為別人發現這些程式碼太難懂了，自己從頭開始寫一個，反而省好多事。 過度地關心“測試”，也會引起過度工程。有些人為了測試，把本來很簡單的程式碼改成“方便測試”的形式，結果引入很多複雜性，以至於本來一下就能寫對的程式碼，最後複雜不堪，出現很多 bug。 世界上有兩種“沒有bug”的程式碼。一種是“沒有明顯的 bug 的程式碼”，另一種是“明顯沒有 bug 的程式碼”。第一種情況，由於程式碼複雜不堪，加上很多測試，各種 coverage，貌似測試都通過了，所以就認為程式碼是正確的。第二種情況，由於程式碼簡單直接，就算沒寫很多測試，你一眼看去就知道它不可能有 bug。 Reference编程的智慧"},{"title":"談 Linux，Windows 和 Mac","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E8%AB%87%20Linux%EF%BC%8CWindows%20%E5%92%8C%20Mac/","tags":[["当然我在扯淡","/tags/%E5%BD%93%E7%84%B6%E6%88%91%E5%9C%A8%E6%89%AF%E6%B7%A1/"],["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"]],"categories":[["undefined",""]],"content":" Linux的Unix的和裡面包含了一些非常糟糕的設計。不要被的Unix的教條主義者嚇倒。學不會有些東西很多時候不是你的錯，而是Linux的的錯，是「Unix的思想」的錯，不要浪費時間去學習太多工具的用法，鑽研稀奇古怪的命令行。那些貌似難的，複雜的東西，特別要小心分析。 學習作業系統最好的辦法是學會（真正的）程式設計思想，而不是去學習各種古怪的工具。所有作業系統，資料庫，網路，以至於 WEB 的設計思想（和缺陷），幾乎都能用程式語言的思想簡單的解釋。 一個好的工具，應該只有少數幾條需要記憶的規則，就像象棋一樣。而這些源於 Unix 的工具卻像是魔鬼棋或者三國殺，有太多的，無聊的，人造的規則。有些人鄙視圖形界面，鄙視IDE，鄙視含有垃圾回收的語言（比如 Java），鄙視一切“容易”的東西。他們卻不知道，把自己沉浸在別人設計的繁複規則中，是始終無法成為大師的。就像一個人，他有能力學會各種魔鬼棋的規則，卻始終無法達到象棋大師的高度。 所以，容易的東西不一定是壞的，而困難的東西也不一定是好的。學習計算機（或者任何其它工具），應該「只選對的，不選難的」記憶一堆的命令，烏七八糟的工具用法，最後腦子裡什麼也不會留下。學習原理性的東西，才是永遠不會過時的。 去除頭腦裡的宗教，偏激，仇恨和鄙視。每次仇恨一個東西，你就失去了向它學習的機會。 Reference談 Linux，Windows 和 Mac"},{"title":"重構","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E9%87%8D%E6%A7%8B/","tags":[["Coding Tips","/tags/Coding-Tips/"]],"categories":[["undefined",""]],"content":"原則 避免冗長的 God Object、參數列表、函式長度、看不懂的變數名稱 如果參數或是專屬某個 data 的相關 function 太多太長，就把它獨立成一個 class。 if / switch 如果沒有過於複雜或太多的操作與頻繁的需求變動，沒有必要把它特地多型化。 減少重複程式碼的數量，為了可讀性，可接受部分重複 參考 如果 method 數量過多，而且無法分離時，可將整包的 method 轉換成 class。但要考慮耦合與複雜度問題。 Replace Method with Method Object 當 parameter 過多時，可以把參數與相關操作方法包裝成 class。 如果舊的演算法，有更好讀的寫法，可進行更換。例如：傳統 for-loop 變成使用函數式語言 each 的方式在尋訪。 Substitute Algorithm 當使用的 library 無法滿足需求時，可自己再包一個 function，如果變動較大的話可包裝成 class。 Introduce Foreign Method 將陣列包裝成物件。 Replace Array with Object jdfiosdjfiodsjfi Reference Refactoring Guru Source Making Refactoring "},{"title":"關於 private 的 visibility - 以 PHP 為範例","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/PHP/%E5%9F%BA%E7%A4%8E%E8%AA%9E%E6%B3%95/%E9%97%9C%E6%96%BC%20private%20%E7%9A%84%20visibility%20-%20%E4%BB%A5%20PHP%20%E7%82%BA%E7%AF%84%E4%BE%8B/","tags":[["PHP","/tags/PHP/"],["OOP","/tags/OOP/"],["coding Tips","/tags/coding-Tips/"]],"categories":[["PHP","/categories/PHP/"],["123","/categories/PHP/123/"]],"content":"Private 的 visibility 只限於被宣告的那個 class。換句話說，除了外部以外，那些繼承了這個 class 的 subclass 一樣也無法訪問到被宣告成 private 的 variable 和 method。因此，即便 parent class 和 child class 擁有同樣的 private method，child class 的 method 也不會 override parent class 的任何 private method。 那為什麼會發生這樣的事情呢？是因為「scope 的不同」，private method/variable 的訪問權被限制在被宣告當下的那個 class 的 scope 下，所以 parent class 和 child class 的 private method/variable 因為 scope 的不同，不會產生 override 的現象。 從上面的例子我們可以看到，child class 向下呼叫 parent class 的 method 的時候，因為 overriden 這個 method 的 scope 在 parent class，所以它最後 echo 出來的是 base。 第二個例子，我們將 visibility 改成 protected 以後，child class 可以訪問到 parent class 的 method，因此對 overriden 這個 method 進行了 override，所以它最後 echo 出來的是 child。 結尾上述對 private method/variable 的例子，可以用其他的程式語言來實現如：Java、C++。最後所得出的結果也是一樣的。 ReferencePHP Visibility"},{"title":"今晚，我想來點 Web 前端效能優化大補帖","date":"2021-05-22T12:32:33.000Z","url":"/2021/05/22/%E4%BB%8A%E6%99%9A%EF%BC%8C%E6%88%91%E6%83%B3%E4%BE%86%E9%BB%9E%20Web%20%E5%89%8D%E7%AB%AF%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E5%A4%A7%E8%A3%9C%E5%B8%96/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"],["front-end","/tags/front-end/"]],"categories":[["undefined",""]],"content":"前言效能是工程師在維護專案時非常重視的要點，不論是 Web 還是 App，甚至是需要大量運算資源的機器學習，都會想追求極致的效能，用高效率換取高價值。 不過，並不是所有的應用都需要追求效能，有時候獲取效能的背後也許需要花上昂貴的成本，比較起來是得不償失的，因此在進行效能調校前應該先好好衡量進行優化的成本（時間、困難度都需要考慮），有時候先求有再求好反而是較佳的方案。 另外一件事就是效能優化沒有所謂的終點，這是一段追求「快還要更快」的過程。 Performance Analyzers在進行效能優化以前，我們得先找出效能瓶頸出自哪裡，這時候我們可以使用一些 performance analyzer 來幫助我們找到問題，其中較有名的是 Lighthouse 與 PageSpeed。 Core Web VitalGoogle 根據長期以來大量的使用者體驗制定出了 Core Web Vital 的指標，Google 更指出若 75% 以上的使用者在網站中的瀏覽體驗都能夠通過以上 3 種指標，就能夠大幅的提升使用者的搜尋體驗，甚至能夠讓原本因等待而離開的使用者減少 24%！ LCP (Largest Contentful Paint ) — 顯示最大內容元素所需時間 (速度)LCP 是計算網頁可視區 (viewport) 中最大元件的載入時間，也就是頁面的主要內容被使用者看到的時間，是速度的指標。 不過可視區內最大的元素並不是固定不變的 上圖的頁面在載入時一開始可視區的最大元素是左上角的文字，接下來隨著頁面載入變成了標題，最後變成了圖片，因為圖片是可視區最大的元素了，因此 LCP 就會以該圖片所需要載入的時間做計算。 如何優化 LCP減少伺服器回應時間 針對主機效能優化 使用較近的 CDN Cache 提早載入第三方資源 盡量避免 Blocking Time 降低 JavaScript blocking time 降低 CSS blocking time 避免使用客戶端渲染(CSR) 若必須使用 CSR ，建議優化 JavaScript ，避免渲染時使用太多資源 盡量在伺服器端完成頁面渲染，讓用戶端取得已渲染好的內容 FID — First Input Delay 首次輸入延遲/封鎖時間總計 (互動性)輸入延遲 (Input Delay) 通常發生於瀏覽器的主執行序過度繁忙，而導致頁面內容無法正確地與使用者進行互動。舉例來說，可能瀏覽器正在載入一支相當肥大的 JavaScript 檔案，導致其他元素不能被載入而延遲可互動的時間。 如何優化 FID 減少 JavaScript 運作的時間 降低網站的 request 數並降低檔案大小 減少主執行序的工作 降低第三方程式碼的影響 CLS — Cumulative Layout Shift 累計版面配置轉移 (穩定性)有沒有遇過一種情況是當你在網頁中準備點擊一個按鈕或連結的瞬間，突然一個廣告被插入，讓你不小心點開別的網站，恨的牙癢癢的呢？這就是 CLS 這個指標想要避免的使用者體驗，如果不清楚以上情境的可以參考這篇 如何避免 CLS 給予會比較慢載入的元素一個預設的寬度與高度 Code Minimize &amp; Uglify有時候你會想看看一些網頁的原始碼是怎麼運作的，不過當點選「檢查網頁原始碼」後，顯示出來的 code 有時卻讓你不知道這到底是哪個星球的程式語言。 不過其實這些看起來混亂的代碼其實就是我們寫出來的程式，雖然變數名稱跟邏輯似乎都跟我們原本開發時寫的不一樣，但它其實只是經過轉譯罷了。而這麼做主要的原因有兩個： 變數跟 code 寫的越短，或是刪除不必要的空白，可以省掉不少瀏覽器 Parse 的時間，也就是提升前端程式的效能 — Minimize 通常會打亂程式的邏輯，避免自家產品的 code 輕鬆的被別人拿去研究或抄襲 — Uglify 如果要試試看效果，可以參考如 JavaScript Minifier 或 Uglify JS 等網頁服務，但通常在開發時我們不會笨拙的手動貼 code 去 Minimize 或 Uglify，而是會利用如 webpack 、gulp 等打包工具替我們做這些事情。 Image Minimize &amp; 理解 jpg、png、 svg 的使用時機現今的網站免不了會需要載入大量的圖片，圖片也因此成為網站載入資源的很大一部分，換句話說就是對網站效能有著直接的影響。在考慮 Image Lazy Load 等技巧以前，我們可以先將圖片壓縮，透過減少檔案大小來加快載入時間，而壓縮又分為兩種狀況： 有損壓縮：如 JPG，使用只取部分像素資料的方式來壓縮圖片大小，並且壓縮後是不可逆的。 無損壓縮：如 PNG，壓縮後不影響圖片品質。 三種圖片類型各自比較有名的圖片壓縮服務有 tiny-png、svgomg、jpeg-optimizer。 而其實不同的圖片類型也有各自適合使用的時機，學會將不同類型圖片應用在適合的地方不僅可以提升使用者體驗或 UI 品質，某些狀況下也可以控制載入資源的大小而提升一點效能。這裡推薦一篇文章，說明得十分完整，除了有介紹各種圖片類型的適當使用時機外，也有介紹如響應式圖片、webp、Image CDN 等其他圖片優化技巧，非常推薦一讀。 Critical Render Path 關鍵渲染路徑提到網頁前端的效能最佳化，我們得先了解網頁是如何渲染到頁面上的，從收到 HTML、CSS 和 JavaScript，再對程式碼進行必需的處理，到最後轉變為顯示像素的過程中還有許多中間步驟。將效能最佳化其實就是瞭解這些步驟中所有的活動，再經過最佳化，這就是所謂的「關鍵渲染路徑（Critical Render Path）」。 根據上圖，我們可以大致理解出網頁渲染的流程為： 讀取 HTML 後生成 DOM Tree 讀取 HTML 中的 CSS Link Tag 生成 CSSOM Tree DOM Tree 與 CSSOM Tree 共同生成 Render Tree 根據 Render Tree 生成 Layout 最後 Paint 畫面 當然，現今的 web app 不太可能只靠 HTML 跟 CSS 就完成，還是得靠 JavaScript 來修改網頁的內容、樣式、與使用者互動的行為。JavaScript 可以查詢及修改 DOM 和 CSSOM，在 CSSOM 執行完畢後，JavaScript 才會執行 。這邊給一個小 tip：如果可以的話，CSS file 盡快引入，JS 在 CSS 後引入，因為 JS的執行會導致網頁載入的暫停（不過有例外的非同步功能）。 一般我們要載入 JavaScript 檔案，通常會透過 &lt;script&gt; 這個 Tag 來達成，不過它的執行是同步的，也就是會導致網頁載入的暫停，如下圖： 但其實 script tag 的引入還有 async 跟 defer 這兩種方式： async 會非同步去請求外部腳本，回應後停止解析執行腳本內容。 defer 也會非同步請求外部腳本，但是等待瀏覽器解析完才執行。 &lt;script async&gt; 用於載入第三方函式庫等不需要動到 DOM 結構的狀況 &lt;script defer &gt; 要整個頁面都下載及分析完成後才會執行，非常類似於把 JS 放在頁尾的情況 Code SplittingCode Splitting 是一個非常重要的觀念，現代網頁程式漸漸走向使用框架以模組化方式來開發，即便會透過如 webpack 等 bundler 來 uglify、minimize、打包程式碼，當專案成長到一定程度時，程式 bundle size 仍然會變得過於肥大，導致 client side 的網頁載入時間變長，嚴重影響使用者體驗。Code Splitting 就是為了要解決單一 JS Bundle 過於肥大的問題，將原本單一的 bundle 切分成數個小 chunk，可以搭配平行載入，或者是有需要時才載入某些特定的 chink，又或是對一些不常變動的 chunk 個別做快取，來達到載入效能的優化。 較常見的 Code Splitting 又分為兩種方式 : 抽離第三方套件 動態載入功能模組 Dynamic Import 抽離第三方套件抽離第三方套件又可以細分兩種方式： 將所有第三方套件打包為單一檔案 將第三方套件打包為多個檔案 將所有第三方套件打包為單一檔案關於 webpack 的 bundle，可以先做一個最大的拆分： Application Bundle ：UI 與商業邏輯，跟我們寫的程式有關，是經常變動的部分。 Vendor Bundle ：第三⽅套件 / node_modules，不太會變動。 拆分出 Vendor Bundle 是有好處的，主要是因為通常它變動的頻率相對較低，因此比較適合被 cache，而在 Vendor Bundle 被 cache 的狀況下由於減少了 Application Bundle 的⼤⼩，因此加快了再訪者的載入速度。採用這樣的方式的優點為邏輯簡單，缺點為更新任何第三方套件都會使快取失效。 將第三方套件打包為多個檔案採用這種方式的優點是可以根據套件關聯性打包，減少套件更新時造成的延遲。缺點則是相較前面打包成單一檔案的方式，這種方式需要處理的邏輯複雜許多。 動態載入功能模組 Dynamic Import大多數狀態下我們會在檔案的開頭引入需要用到的模組，這些模組通常在網頁載入時就被引入進來，這種方式被稱為 static import，然而當有以下兩種狀況的需求時，static import 卻不能滿足我們： 模組名稱為動態變數時 需依照特定邏輯或特定時機引入時 這時候可以運用與之相對的技術： Dynamic Import。所謂 Dynamic Import 代表的即是 需要用到某段程式碼時才透過網路載入 JS bundle Webpack Bundle Analyzer 透過 webpack-bundle-analyzer，我們可以透過視覺化分析專案有哪些 bundle chunk，各個 bundle chunk 的組成又為何，再針對可以改進的 bundle 進行優化。 （類似功能的工具還有如 WebpackVisualizerPlugin） Lazy Load Image稍早的 Image Minimize 段落中有提到圖片佔了網站資源相當大的比例，因此如果在網頁載入的瞬間就想把所有圖片都載入下來對效能是一個硬傷，這時候可以採用 lazy load 的方法去載入圖片，一開始只需載入部分的圖片，待現有圖片快要接觸到 viewport 的底部時再去動態載入新的圖片，例如 imgur 這種圖床網站就勢必會做圖片的 lazy load。 要實現 image 的 lazy load 主要有兩種方式： 搭配 Intersection Observer web API : 偵測目標元素是不是與特定位置交會，交會時再去載入新的資源。(可以參考我很久以前寫的練習作業) 瀏覽器原生支援 (參考連結) Virtualized List長列表（例如大量的文章列表）是網站中蠻常見的一個 feature，然而如果有 1000 篇文章，我們又將這些文章同時渲染的話，就必須生成 1000 個 dom 節點，更不用說文章結構通常是相對複雜的，像這樣同時渲染數量頗大的元素會有幾個明顯的缺點： 載入時白屏時間會比較長 渲染了大量的 dom 節點的狀況下，在滾動事件觸發時會大大增加記憶體的用量 容易失幀，因為渲染很慢，所以無法維持瀏覽器的幀率，頁面會顯得卡頓 最慘的話網頁會失去響應 而且這些問題在 Desktop 瀏覽器就會發生了，換作是手機瀏覽器只會讓問題變得更嚴重，因此這種狀況下我們應該優化長列表，提升使用者體驗。 virtualized list 就是優化長列表的一種技巧，名字聽起來很深奧，不過它的概念其實非常簡單： 用陣列儲存所有列表元素的位置，只渲染可視區 (viewport)內的列表元素，當可視區滾動時，根據滾動的 offset 大小以及所有列表元素的位置，計算在可視區應該渲染哪些元素。 以上圖來說，假設可視區最多只能顯示 6 個 item，那即使我們的列表總共有 1000 個，也只會渲染出現在可視區的 6 個元素，當原本被渲染的 item 移出可視區後，就會被 unmount 掉，避免前面說的同時生成一堆 dom 節點的狀況，也因此有效的解決了上面說的幾個缺點。 如果對如何實作一個 virtualized list 有興趣，可以參考這篇文章。 Tree Shaking開發專案免不了會下載第三方套件來節省自己重複造輪子的成本，然而也許某些狀況我們只會使用一個套件模組之中的特定幾個 function，其他的 function 幾乎都不會用到。不過如果我們為了這幾個 function 而要載入整個模組，就似乎有點得不償失了，這時候 Tree shaking 會是解救我們的技巧。 什麼是 Tree Shaking ?其實這個技巧跟字面上的意思很像，當用力搖一棵樹時可能會把很笨重的果實給搖落，在程式面來說就是把「用不到的程式碼給搖落下來」，上面的例子講到我們可能會為了幾個特定函式而需要載入整個套件，運用 Tree Shaking 之後，可以讓打包工具在打包階段就可以分析哪些 code 或哪些 function 是用不到的，而把它們從最終的 bundle 中剔除，換句話說就是確保最後的 bundle 不會包含無用或多餘的程式碼與資源，減少 bundle size。 如何做到 Tree Shaking ?要做到 Tree Shaking，首先得透過 ES6 import export 的幫忙 假設我們要使用 array-utils 中的某幾個函式，應該避免上面的引入方式（把整個 array-utils 引入進來，再去使用特定的 property），而改為下面這種引入方式： 不過此時如果用打包工具例如 webpack 打包的話，還是會將整個 array-utils 加進 bundle 裡，此時還得靠例如 uglifyjs-webpack-plugin 或其他的 plugin 再加上一些額外設定才能把用不到的程式從 bundle 中移除 Preload、Prefetch And Others In Link Tag這邊要介紹五個特殊的 link 技巧：prefetch、preload、preconnect、dns-preconnect、prerender。讀者可能看起來一頭霧水，不過其實它們都有一個共同的目標，或者說共同的效能優化方式： 對不久的將來會用到的資源預先處理，這裡的處理有可能是載入資源，或是建立連線，因此在真的要使用到該資源時可以省去不少時間。 Preload VS Prefetchpreload 與 prefetch 是兩個較常被搞混的技巧，兩者的作用都是在提早取得將來會用到的資源，然而兩者的差別在於： Preload：取得當前頁面的資源（例如字體 font）。 Prefetch：告訴瀏覽器「這些資源我待會會用到，先幫我下載吧！」不過與 preload 不同的是 prefetch 抓取的資源不限於當前頁面使用，也就是可以跨越 navigation，例如你很確定使用者會點擊下一頁，就可以使用 prefetch 預先抓取下一頁的資源。 瀏覽器對於資源的載入順序是有規則的，是以檔案類型來決定下載的優先順序，以 chrome 舉例來說（不確定不同瀏覽器是否不同）： High priority : style /font / XHR (sync) Medium priority : 位於可視區域的圖片 / Preload without as/ XHR (async) Low priority : favicon、script async / defer / block、不在可視區域的圖片、媒體檔、SVG 等 Preconnectpreconnect 相當於告訴瀏覽器：「這個網頁將會在不久的將來下載某個 domain 的資源，請先幫我建立好連線。」 要理解 preconnect 能夠達成的事，得了解瀏覽器在實際傳輸資源前，實際上經過哪些步驟（以下內容與圖片參考這篇文章）： 向 DNS 請求解析網域名 TCP Handshake (HTTPS connection) SSL Negotiation 建立連線完成，等待拿到資料的第一個byte 上面的四個步驟中，每一步都會需要一個 RTT (Round Trip Time) 的來回時間。所以在實際傳輸資料之前，已經花了3個 RTT 的時間。如果在網路狀況很差的狀況下，會讓獲取資源的速度大大降低。 利用 preconnect 提早建立好與特定 domain 之間的連線，省去了一次完整的 (DNS Lookup + TCP Handshake + SSL Negotiation) ，共三個 Round Trip Time 的時間。 Preconnect Use Cases :通常只會對確定短時間內就會用到的 domain 做 preconnect，因為如果 10 秒內沒有使用的話瀏覽器會自動把連線 close 掉 CDN：如果網站中有很多資源要從 CDN 拿取，可以 preconnect CDN 的域名，這在不能預先知道有哪些資源要抓取的情況，是蠻適合的 use case。 Streaming 串流媒體 （待會看下方 lite-youtube-embed 的例子） DNS Preconnect跟 preconnect 類似，差別在於只提示瀏覽器預先處理第一步 DNS lookup 而已。至於什麼時機要使用哪個方式，可以參考這篇 stackoverflow 問題 Prerenderprerender 比 prefetch 更進一步。不僅僅會下載對應的資源，還會對資源進行解析。解析過程中，如果需要其他的資源，可能會直接下載這些資源，基本上就是盡可能預先渲染下個頁面，這樣一來當用戶在從當前頁面跳轉到目標頁面時，瀏覽器可以快速的響應。適合用在用戶很高機率會轉到另一個頁面的狀況下使用 CDN &amp; CacheCDN 的全名為：「Content Delivery Network 內容傳遞網路」。 要知道距離不僅僅是愛情的毒藥（誤），也是影響 response time 的重大因素。假設你身在台灣，跟一個架設在台灣的 server 取資料，花費的時間只要 500 ms，但如果去跟一個架設在美國的 server 取相同的資料，這時候的 response time 可能就增長為 3000 ms。 CDN 就是透過在各個地理位置建立 edge server 來避免取資源時都要跟距離遙遠的 server 溝通，造成效能的低落。當使用者對被 CDN 加速過的域名發出 request 時，CDN 會自動將 request 導到地理位置離使用者較近或是流量較不吃緊的 edge server，儘管第一次取資源時因為 CDN 還沒有快取的資料，所以仍然需要跟 original server 要資料，不過之後的 request 就可以透過地理位置離使用者較近的 CDN cache 取得，加快 client 端資源載入的速度。除了 cahce 機制以外，CDN 某方面也算是增強了服務的可用性、負載功能、安全性（降低 DDOS 對網站的影響）。 如果要更深入了解 CDN 或者 networking cache，推薦參考這篇鐵人賽的優質文章。 而目前最熱門的免費 CDN 服務大概就是 Cloudflare 了， 它主要提供的服務有： CDN Cache Load Balancing 代管 DNS 阻擋惡意流量 Reference今晚，我想來點 Web 前端效能優化大補帖"}]